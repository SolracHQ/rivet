---@meta

---Process execution module for Rivet pipelines
---
---Provides controlled process execution within containers.
---All process.run() calls execute inside the current container context.
---If no container is active, processes run in a default Alpine container.
---
---The module handles stdout/stderr capture and logging integration,
---allowing fine-grained control over process output handling.
---
---@class process
process = {}

---Result of a process execution
---@class ProcessResult
---@field stdout string|nil Captured stdout (if capture_stdout was true)
---@field stderr string|nil Captured stderr (if capture_stderr was true)
---@field exit_code number The process exit code

---Options for process execution
---@class ProcessOptions
---@field cmd string The command to execute (binary name or path)
---@field args string[]|nil Arguments to pass to the command
---@field capture_stdout boolean|nil Capture stdout and return it (default: false)
---@field capture_stderr boolean|nil Capture stderr and return it (default: false)
---@field capture_exit_code boolean|nil Capture exit code (default: true, always returned)
---@field stdout_level string|nil Log level for stdout ("debug"|"info"|"warning"|"error", default: "info")
---@field stderr_level string|nil Log level for stderr ("debug"|"info"|"warning"|"error", default: "error")
---@field env table<string, string>|nil Additional environment variables to set
---@field cwd string|nil Working directory (relative to /workspace, default: /workspace)

---Execute a process inside the current container context
---
---Runs the specified command with the given arguments. Output is automatically
---logged unless explicitly captured. Exit codes are always returned.
---
---If the process exits with a non-zero code, it does NOT automatically error.
---Check the exit_code in the result if you want to handle failures.
---
---@param options ProcessOptions Configuration for process execution
---@return ProcessResult result The result of the process execution
---
---@usage
---Simple command execution
---local result = process.run({cmd = "echo", args = {"Hello, World!"}})
---log.info("Exit code: " .. result.exit_code)
---
---@usage
---Capture output for processing
---local result = process.run({
---    cmd = "git",
---    args = {"rev-parse", "HEAD"},
---    capture_stdout = true
---})
---local commit_sha = result.stdout:gsub("%s+", "")  -- trim whitespace
---output.set("commit_sha", commit_sha)
---
---@usage
---Custom logging levels
---process.run({
---    cmd = "npm",
---    args = {"install"},
---    stdout_level = "debug",  -- npm output at debug level
---    stderr_level = "warning" -- npm errors at warning level
---})
---
---@usage
---Check exit code and handle errors
---local result = process.run({
---    cmd = "cargo",
---    args = {"test"}
---})
---if result.exit_code ~= 0 then
---    log.error("Tests failed with exit code: " .. result.exit_code)
---    error("Test suite failed")
---end
---
---@usage
---Set environment variables
---process.run({
---    cmd = "make",
---    args = {"build"},
---    env = {
---        CC = "gcc",
---        CFLAGS = "-O2 -Wall"
---    }
---})
---
---@usage
---Run in a specific directory
---process.run({
---    cmd = "npm",
---    args = {"run", "build"},
---    cwd = "frontend"  -- runs in /workspace/frontend
---})
---
---@usage
---Capture both stdout and stderr
---local result = process.run({
---    cmd = "curl",
---    args = {"-v", "https://api.example.com"},
---    capture_stdout = true,
---    capture_stderr = true
---})
---log.debug("Response: " .. (result.stdout or ""))
---log.debug("Verbose output: " .. (result.stderr or ""))
function process.run(options) end
